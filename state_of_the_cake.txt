---------------------- notions techniques EKF -----------------------------

* x = state
* u = inputs -> data "indirecte" (i.e. qui n'est pas tracked dans le state vector)
* z = observations -> data "directe" (i.e. qui est tracked dans le state vector)
* w = bruits 

* f(x, u, [w]) = fonction de prédiction -> donne l'estimation de (dx/dt)
* F = jacobienne de f
* Q = matrice des covariances
* Qs = matrice de drift

* h(x) = fonction d'observation -> donne l'estimation de z 
* H = jacobienne de h
* R = matrice d'incertitude de mesure (covariances des mesures)
	-> incertitude ~= bruit

* S = matrice intermédière -> var(estimations) + var(mesures)
* K = gain de Kalman -> var(estimations) / S

-------------------------- implémentation --------------------------------

* les bias, bruits & drifts prennent le temps en compte
	-> car le seraient tjrs dans le code, donc gain en perf

* on inclus les bias dans le state vector
	-> permet de drift automatiquement en ajoutant un matrice à P : Qs
	-> cette partie du filtre est un "filtre bayésien récursif"

* on utilise des quaternions
	-> obligatoire d'enforce norm(q) = 1
	-> q(k) = dq(k)*q(k-1) et non dq(k) + q(k-1) : "Multiplicative EKF (MEKF)"

* tous les vecteurs/matrices sont "préintégrés" (x_new, F, Q, ...)
	-> d'où le temps dans les bruits
	-> sur les matrices/vecteurs: certaines composantes ne doivent pas etre mult par le temps ou sont traitées particulièrement

* pour inclures des sensors différents mesurant une même donnée
	-> inputs (u) : moyenne inverse variance (moyenne pondérée où chaque coeff est 1/var(sensor)) : plus la mesure est précise, plus elle est importante dans le blend
	-> observations (z) : ajouter une/des ligne/s à h, H et R

* pour baro (enft pour tout z)
	-> on remrque qu'un R pas mal plus fort que le bruit calculé marche mieux
	-> TODO

--------------------------- run actuelle ---------------------------------

* covariance sur la vitesse (par extension, sur la position)
	-> x,y diverge : pas d'observations
	-> z stable : observation

* énorme spik sur pos_z au début
	-> mesure de acc_z dégueulasse
	-> se stabilise dans un range acceptable in fine

* q(3) climb : why ?
	-> alors que la norme reste globamlement la même
	-> TODO

--------------------------- modèle future ---------------------------------

* magnétomètre : tracked
 -> dx/dt associé = 0 car mesure dans z et non u