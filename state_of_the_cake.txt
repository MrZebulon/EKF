---------------------- notions techniques EKF -----------------------------

* x = state
* u = inputs -> data "indirecte" (i.e. qui n'est pas tracked dans le state vector)
* z = observations -> data "directe" (i.e. qui est tracked dans le state vector)
* w = bruits 

* f(x, u, [w]) = fonction de prédiction -> donne l'estimation de (dx/dt)
* F = jacobienne de f
* Q = matrice des covariances
* Qs = matrice de drift

* h(x) = fonction d'observation -> donne l'estimation de z 
* H = jacobienne de h
* R = matrice d'incertitude de mesure (covariances des mesures)
	-> bruit != incertitude

* S = matrice intermédière -> var(estimations) + var(mesures)
* K = gain de Kalman -> var(estimations) / S

-------------------------- implémentation --------------------------------

* les bias, bruits & drifts prennent le temps en compte
	-> car le seraient tjrs dans le code, donc gain en perf

* on inclus les bias dans le state vector
	-> permet de drift automatiquement en ajoutant un matrice à P : Qs
	-> cette partie du filtre est un "filtre bayésien récursif"

* on utilise des quaternions
	-> obligatoire d'enforce norm(q) = 1
	-> q(k) = dq(k)*q(k-1) et non dq(k) + q(k-1) : "Multiplicative EKF (MEKF)"

* toutes les quantités sont "préintégrés" (F, Q, ...)
	-> d'où le temps dans les bruits
	-> sur les matrices/vecteurs: certaines composantes ne doivent pas etre mult par le temps ou sont traitées particulièrement

--------------------------- run actuelle ---------------------------------
* covariance sur la vitesse (par extension, sur la position)
	-> x,y diverge : pas d'observations
	-> z stable : observation

* q(3) climb : why ?
	-> alors que la norme reste globamlement la même